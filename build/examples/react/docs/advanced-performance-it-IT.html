<!DOCTYPE html><!--[if IE]><![endif]--><html><head><meta charset=utf-8><meta content="IE=edge,chrome=1" http-equiv=X-UA-Compatible><title>Performance Avanzata | React</title><meta content="width=device-width" name=viewport><meta content="Performance Avanzata | React" property=og:title><meta content=website property=og:type><meta content=https://facebook.github.io/fastastic/examples/react/docs/advanced-performance-it-IT.html property=og:url><meta content=https://facebook.github.io/fastastic/examples/react/img/logo_og.png property=og:image><meta content="A JavaScript library for building user interfaces" property=og:description><meta content=623268441017527 property=fb:app_id><link href=/fastastic/examples/react/favicon.ico rel="shortcut icon"><link href=https://facebook.github.io/fastastic/examples/react/feed.xml rel=alternate title=React type=application/rss+xml><link href=https://cdn.jsdelivr.net/docsearch.js/1/docsearch.min.css rel=stylesheet><link href=/fastastic/examples/react/css/syntax.css rel=stylesheet><link href=/fastastic/examples/react/css/codemirror.css rel=stylesheet><link href=/fastastic/examples/react/css/react.css rel=stylesheet><script src=//use.typekit.net/vqa1hcx.js></script><script>try{Typekit.load()}catch(t){}</script><!--[if lte IE 8]>
  <script src="/fastastic/examples/react/js/html5shiv.min.js"></script>
  <script src="/fastastic/examples/react/js/es5-shim.min.js"></script>
  <script src="/fastastic/examples/react/js/es5-sham.min.js"></script>
  <![endif]--><script src=https://cdn.jsdelivr.net/docsearch.js/1/docsearch.min.js></script><script src=/fastastic/examples/react/js/codemirror.js></script><script src=/fastastic/examples/react/js/javascript.js></script><script src=/fastastic/examples/react/js/xml.js></script><script src=/fastastic/examples/react/js/jsx.js></script><script src=/fastastic/examples/react/js/react.js></script><script src=/fastastic/examples/react/js/react-dom.js></script><script src=/fastastic/examples/react/js/babel-browser.min.js></script><script src=/fastastic/examples/react/js/live_editor.js></script></head><body><div class=container><div class=nav-main><div class=wrap><a href=/fastastic/examples/react/index.html class=nav-home><img class=nav-logo height=36 src=/fastastic/examples/react/img/logo.svg width=36> React</a><ul class="nav-site nav-site-internal"><li><a href=/fastastic/examples/react/docs/getting-started.html class=active>Docs</a></li><li><a href=/fastastic/examples/react/support.html>Support</a></li><li><a href=/fastastic/examples/react/downloads.html>Download</a></li><li><a href=/fastastic/examples/react/blog/ >Blog</a></li><li><input id=algolia-doc-search placeholder="Search docs..." type=text></li></ul><ul class="nav-site nav-site-external"><li><a href=https://github.com/facebook/react>GitHub</a></li><li><a href=https://facebook.github.io/react-native/ >React Native</a></li></ul></div></div><section class="wrap content documentationContent"><div class=nav-docs><!-- Docs Nav --><div class=nav-docs-section><h3>Quick Start</h3><ul><li><a href=/fastastic/examples/react/docs/getting-started.html>Getting Started</a></li><li><a href=/fastastic/examples/react/docs/tutorial.html>Tutorial</a></li><li><a href=/fastastic/examples/react/docs/thinking-in-react.html>Thinking in React</a></li></ul></div><div class=nav-docs-section><h3>Community Resources</h3><ul><li><a href=/fastastic/examples/react/docs/conferences.html>Conferences</a></li><li><a href=/fastastic/examples/react/docs/videos.html>Videos</a></li><li><a href=https://github.com/facebook/fastastic/examples/react/wiki/Complementary-Tools class=external>Complementary Tools</a></li><li><a href=https://github.com/facebook/fastastic/examples/react/wiki/Examples class=external>Examples</a></li></ul></div><div class=nav-docs-section><h3>Guides</h3><ul><li><a href=/fastastic/examples/react/docs/why-react.html>Why React?</a></li><li><a href=/fastastic/examples/react/docs/displaying-data.html>Displaying Data</a><ul><li><a href=/fastastic/examples/react/docs/jsx-in-depth.html>JSX in Depth</a></li><li><a href=/fastastic/examples/react/docs/jsx-spread.html>JSX Spread Attributes</a></li><li><a href=/fastastic/examples/react/docs/jsx-gotchas.html>JSX Gotchas</a></li></ul></li><li><a href=/fastastic/examples/react/docs/interactivity-and-dynamic-uis.html>Interactivity and Dynamic UIs</a></li><li><a href=/fastastic/examples/react/docs/multiple-components.html>Multiple Components</a></li><li><a href=/fastastic/examples/react/docs/reusable-components.html>Reusable Components</a></li><li><a href=/fastastic/examples/react/docs/transferring-props.html>Transferring Props</a></li><li><a href=/fastastic/examples/react/docs/forms.html>Forms</a></li><li><a href=/fastastic/examples/react/docs/working-with-the-browser.html>Working With the Browser</a><ul><li><a href=/fastastic/examples/react/docs/more-about-refs.html>Refs to Components</a></li></ul></li><li><a href=/fastastic/examples/react/docs/tooling-integration.html>Tooling Integration</a><ul><li><a href=/fastastic/examples/react/docs/language-tooling.html>Language Tooling</a></li><li><a href=/fastastic/examples/react/docs/package-management.html>Package Management</a></li><li><a href=/fastastic/examples/react/docs/environments.html>Server-side Environments</a></li></ul></li><li><a href=/fastastic/examples/react/docs/addons.html>Add-Ons</a><ul><li><a href=/fastastic/examples/react/docs/animation.html>Animation</a></li><li><a href=/fastastic/examples/react/docs/two-way-binding-helpers.html>Two-Way Binding Helpers</a></li><li><a href=/fastastic/examples/react/docs/test-utils.html>Test Utilities</a></li><li><a href=/fastastic/examples/react/docs/clone-with-props.html>Cloning Elements</a></li><li><a href=/fastastic/examples/react/docs/create-fragment.html>Keyed Fragments</a></li><li><a href=/fastastic/examples/react/docs/update.html>Immutability Helpers</a></li><li><a href=/fastastic/examples/react/docs/pure-render-mixin.html>PureRenderMixin</a></li><li><a href=/fastastic/examples/react/docs/perf.html>Performance Tools</a></li><li><a href=/fastastic/examples/react/docs/shallow-compare.html>Shallow Compare</a></li></ul></li><li><a href=/fastastic/examples/react/docs/advanced-performance.html>Advanced Performance</a></li><li><a href=/fastastic/examples/react/docs/context.html>Context</a></li></ul></div><div class=nav-docs-section><h3>Reference</h3><ul><li><a href=/fastastic/examples/react/docs/top-level-api.html>Top-Level API</a></li><li><a href=/fastastic/examples/react/docs/component-api.html>Component API</a></li><li><a href=/fastastic/examples/react/docs/component-specs.html>Component Specs and Lifecycle</a></li><li><a href=/fastastic/examples/react/docs/tags-and-attributes.html>Supported Tags and Attributes</a></li><li><a href=/fastastic/examples/react/docs/events.html>Event System</a></li><li><a href=/fastastic/examples/react/docs/dom-differences.html>DOM Differences</a></li><li><a href=/fastastic/examples/react/docs/special-non-dom-attributes.html>Special Non-DOM Attributes</a></li><li><a href=/fastastic/examples/react/docs/reconciliation.html>Reconciliation</a></li><li><a href=/fastastic/examples/react/docs/webcomponents.html>Web Components</a></li><li><a href=/fastastic/examples/react/docs/glossary.html>React (Virtual) DOM Terminology</a></li></ul></div><!-- Tips Nav --><div class=nav-docs-section><h3>Tips</h3><ul><li><a href=/fastastic/examples/react/tips/introduction.html>Introduction</a></li><li><a href=/fastastic/examples/react/tips/inline-styles.html>Inline Styles</a></li><li><a href=/fastastic/examples/react/tips/if-else-in-JSX.html>If-Else in JSX</a></li><li><a href=/fastastic/examples/react/tips/self-closing-tag.html>Self-Closing Tag</a></li><li><a href=/fastastic/examples/react/tips/maximum-number-of-jsx-root-nodes.html>Maximum Number of JSX Root Nodes</a></li><li><a href=/fastastic/examples/react/tips/style-props-value-px.html>Shorthand for Specifying Pixel Values in style props</a></li><li><a href=/fastastic/examples/react/tips/children-props-type.html>Type of the Children props</a></li><li><a href=/fastastic/examples/react/tips/controlled-input-null-value.html>Value of null for Controlled Input</a></li><li><a href=/fastastic/examples/react/tips/componentWillReceiveProps-not-triggered-after-mounting.html>componentWillReceiveProps Not Triggered After Mounting</a></li><li><a href=/fastastic/examples/react/tips/props-in-getInitialState-as-anti-pattern.html>Props in getInitialState Is an Anti-Pattern</a></li><li><a href=/fastastic/examples/react/tips/dom-event-listeners.html>DOM Event Listeners in a Component</a></li><li><a href=/fastastic/examples/react/tips/initial-ajax.html>Load Initial Data via AJAX</a></li><li><a href=/fastastic/examples/react/tips/false-in-jsx.html>False in JSX</a></li><li><a href=/fastastic/examples/react/tips/communicate-between-components.html>Communicate Between Components</a></li><li><a href=/fastastic/examples/react/tips/expose-component-functions.html>Expose Component Functions</a></li><li><a href=/fastastic/examples/react/tips/children-undefined.html>this.props.children undefined</a></li><li><a href=/fastastic/examples/react/tips/use-react-with-other-libraries.html>Use React with Other Libraries</a></li><li><a href=/fastastic/examples/react/tips/dangerously-set-inner-html.html>Dangerously Set innerHTML</a></li></ul></div><!-- Contributing Nav --><div class=nav-docs-section><h3>Contributing</h3><ul><li><a href=/fastastic/examples/react/contributing/design-principles.html>Design Principles</a></li></ul></div></div><div class=inner-content><a href=https://github.com/facebook/fastastic/examples/react/tree/master/docs/docs/11-advanced-performance.it-IT.md class=edit-page-link target=_blank>Edit on GitHub</a><h1>Performance Avanzata</h1><div class=subHeader></div><p>Una tra le prime domande che la gente si pone quando considera React per un progetto è se l&#39;applicazione sarà altrettanto veloce e scattante di una versione equivalente non basata su React. L&#39;idea di ripetere il rendering di un intero sottoalbero di componenti in risposta a ciascun cambiamento dello stato rende la gente curiosa se questo processo influisce negativamente sulle prestazioni. React utilizza diverse tecniche intelligenti per minimizzare il numero di operazioni costose sul DOM richieste dall&#39;aggiornamento della UI.</p><h2><a class=anchor name=evitare-di-riconciliare-il-dom></a>Evitare di riconciliare il DOM <a href=#evitare-di-riconciliare-il-dom class=hash-link>#</a></h2><p>React fa uso di un <em>DOM virtuale</em>, che è un descrittore di un sottoalbero DOM visualizzato nel browser. Questa rappresentazione parallela permette a React di evitare di creare nodi DOM e accedere nodi esistenti, che è di gran lunga più lento di operazioni su oggetti JavaScript. Quando le proprietà di un componente o il suo stato cambiano, React decide se un&#39;aggiornamento effettivo del DOM sia necessario costruendo un nuovo virtual DOM e confrontandolo con quello vecchio. Solo nel caso in cui non siano uguali, React <a href=/fastastic/examples/react/docs/reconciliation.html>riconcilierà</a> il DOM, applicando il minor numero di mutamenti possibile.</p><p>In aggiunta a questo, React offre una funzione per il ciclo di vita del componente, <code>shouldComponentUpdate</code>, che viene scatenata prima che il processo di ri-rendering cominci (il confronto del DOM virtuale e una possibile eventuale riconciliazione del DOM), dando allo sviluppatore la possibilità di cortocircuitare questo processo. L&#39;implementazione predefinita di questa funzione restituisce <code>true</code>, lasciando che React effettui l&#39;aggiornamento:</p><div class=highlight><pre><code class=language-javascript data-lang=javascript><span class=nx>shouldComponentUpdate</span><span class=o>:</span> <span class=kd>function</span><span class=p>(</span><span class=nx>nextProps</span><span class=p>,</span> <span class=nx>nextState</span><span class=p>)</span> <span class=p>{</span>
  <span class=k>return</span> <span class=kc>true</span><span class=p>;</span>
<span class=p>}</span>
</code></pre></div><p>Tieni in mente che React invocherà questa funzione abbastanza spesso, quindi l&#39;implementazione deve essere veloce.</p><p>Supponiamo che hai un&#39;applicazione di messaggistica con parecchi thread di conversazioni. Supponi che solo uno dei thread sia cambiato. Se implementassimo <code>shouldComponentUpdate</code> sul componente <code>ChatThread</code>, React potrebbe saltare la fase di rendering per gli altri thread:</p><div class=highlight><pre><code class=language-javascript data-lang=javascript><span class=nx>shouldComponentUpdate</span><span class=o>:</span> <span class=kd>function</span><span class=p>(</span><span class=nx>nextProps</span><span class=p>,</span> <span class=nx>nextState</span><span class=p>)</span> <span class=p>{</span>
  <span class=c1>// TODO: restituisci true se il thread attuale è diverso</span>
  <span class=c1>// da quello precedente.</span>
<span class=p>}</span>
</code></pre></div><p>Quindi, riassumendo, React evita di effettuare operazioni costose sul DOM richieste a riconciliare sottoalberi del DOM, permettendo all&#39;utente di cortocircuitare il processo usando <code>shouldComponentUpdate</code>, e, per i casi in cui si debba aggiornare, confrontando i DOM virtuali.</p><h2><a class=anchor name=shouldcomponentupdate-in-azione></a>shouldComponentUpdate in azione <a href=#shouldcomponentupdate-in-azione class=hash-link>#</a></h2><p>Ecco un sottoalbero di componenti. Per ciascuno di essi viene indicato cosa <code>shouldComponentUpdate</code> ha restituito e se i DOM virtuali siano equivalenti o meno. Infine, il colore del cerchio indica se il componente sia stato riconciliato o meno.</p><figure><img src=/fastastic/examples/react/img/docs/should-component-update.png></figure><p>Nell&#39;esempio precedente, dal momento che <code>shouldComponentUpdate</code> ha restituito <code>false</code> per il sottoalbero di radice C2, React non ha avuto bisogno di generare il nuovo DOM virtuale, e quindi non ha nemmeno avuto bisogno di riconciliare il DOM. Nota che React non ha nemmeno avuto bisogno di invocare <code>shouldComponentUpdate</code> su C4 e C5.</p><p>Per C1 e C3, <code>shouldComponentUpdate</code> ha restituito <code>true</code>, quindi React è dovuto scendere giù fino alle foglie e controllarle. Per C6 ha restituito <code>true</code>; dal momento che i DOM virtuali non erano equivalenti, ha dovuto riconciliare il DOM. L&#39;ultimo caso interessante è C8. Per questo nodo React ha dovuto calcolare il DOM virtuale, ma dal momento che era uguale al vecchio, non ha dovuto riconciliare il suo DOM.</p><p>Nota che React ha dovuto effettuare mutazioni del DOM soltanto per C6, che era inevitabile. Per C8, lo ha evitato confrontando i DOM virtuali, e per il sottoalbero di C2 e C7, non ha neppure dovuto calcolare il DOM virtuale in quanto è stato esonerato da <code>shouldComponentUpdate</code>.</p><p>Quindi, come dovremmo implementare <code>shouldComponentUpdate</code>? Supponiamo di avere un componente che visualizza soltanto un valore stringa:</p><div class=highlight><pre><code class=language-javascript data-lang=javascript><span class=nx>React</span><span class=p>.</span><span class=nx>createClass</span><span class=p>({</span>
  <span class=nx>propTypes</span><span class=o>:</span> <span class=p>{</span>
    <span class=nx>value</span><span class=o>:</span> <span class=nx>React</span><span class=p>.</span><span class=nx>PropTypes</span><span class=p>.</span><span class=nx>string</span><span class=p>.</span><span class=nx>isRequired</span>
  <span class=p>},</span>

  <span class=nx>render</span><span class=o>:</span> <span class=kd>function</span><span class=p>()</span> <span class=p>{</span>
    <span class=k>return</span> <span class=o>&lt;</span><span class=nx>div</span><span class=o>&gt;</span><span class=p>{</span><span class=k>this</span><span class=p>.</span><span class=nx>props</span><span class=p>.</span><span class=nx>value</span><span class=p>}</span><span class=o>&lt;</span><span class=err>/div&gt;;</span>
  <span class=p>}</span>
<span class=p>});</span>
</code></pre></div><p>Potremmo facilmente implementare <code>shouldComponentUpdate</code> come segue:</p><div class=highlight><pre><code class=language-javascript data-lang=javascript><span class=nx>shouldComponentUpdate</span><span class=o>:</span> <span class=kd>function</span><span class=p>(</span><span class=nx>nextProps</span><span class=p>,</span> <span class=nx>nextState</span><span class=p>)</span> <span class=p>{</span>
  <span class=k>return</span> <span class=k>this</span><span class=p>.</span><span class=nx>props</span><span class=p>.</span><span class=nx>value</span> <span class=o>!==</span> <span class=nx>nextProps</span><span class=p>.</span><span class=nx>value</span><span class=p>;</span>
<span class=p>}</span>
</code></pre></div><p>Finora tutto a posto, maneggiare queste semplici strutture proprietà e stato è molto facile. Potremmo anche generalizzare un&#39;implementazione basata sull&#39;uguaglianza superficiale e farne il mix dentro i componenti. Infatti, React fornisce già una tale implementazione: <a href=/fastastic/examples/react/docs/pure-render-mixin.html>PureRenderMixin</a>.</p><p>Ma che succede se le proprietà o lo stato del tuo componente sono strutture dati mutevoli? Supponiamo che la proprietà che il componente riceve sia, anziché una stringa come <code>&#39;bar&#39;</code>, un oggetto JavaScript che contiene una stringa, come <code>{ foo: &#39;bar&#39; }</code>:</p><div class=highlight><pre><code class=language-javascript data-lang=javascript><span class=nx>React</span><span class=p>.</span><span class=nx>createClass</span><span class=p>({</span>
  <span class=nx>propTypes</span><span class=o>:</span> <span class=p>{</span>
    <span class=nx>value</span><span class=o>:</span> <span class=nx>React</span><span class=p>.</span><span class=nx>PropTypes</span><span class=p>.</span><span class=nx>object</span><span class=p>.</span><span class=nx>isRequired</span>
  <span class=p>},</span>

  <span class=nx>render</span><span class=o>:</span> <span class=kd>function</span><span class=p>()</span> <span class=p>{</span>
    <span class=k>return</span> <span class=o>&lt;</span><span class=nx>div</span><span class=o>&gt;</span><span class=p>{</span><span class=k>this</span><span class=p>.</span><span class=nx>props</span><span class=p>.</span><span class=nx>value</span><span class=p>.</span><span class=nx>foo</span><span class=p>}</span><span class=o>&lt;</span><span class=err>/div&gt;;</span>
  <span class=p>}</span>
<span class=p>});</span>
</code></pre></div><p>L&#39;implementazione di <code>shouldComponentUpdate</code> che avevamo prima non funzionerebbe sempre come ci aspettiamo:</p><div class=highlight><pre><code class=language-javascript data-lang=javascript><span class=c1>// assumiamo che this.props.value sia { foo: &#39;bar&#39; }</span>
<span class=c1>// assumiamo che nextProps.value sia { foo: &#39;bar&#39; },</span>
<span class=c1>// ma questo riferimento è diverso da this.props.value</span>
<span class=k>this</span><span class=p>.</span><span class=nx>props</span><span class=p>.</span><span class=nx>value</span> <span class=o>!==</span> <span class=nx>nextProps</span><span class=p>.</span><span class=nx>value</span><span class=p>;</span> <span class=c1>// true</span>
</code></pre></div><p>Il problema è che <code>shouldComponentUpdate</code> restituirà <code>true</code> quando la proprietà non è in realtà cambiata. Per risolvere questo problema, potremmo proporre questa implementazione alternativa:</p><div class=highlight><pre><code class=language-javascript data-lang=javascript><span class=nx>shouldComponentUpdate</span><span class=o>:</span> <span class=kd>function</span><span class=p>(</span><span class=nx>nextProps</span><span class=p>,</span> <span class=nx>nextState</span><span class=p>)</span> <span class=p>{</span>
  <span class=k>return</span> <span class=k>this</span><span class=p>.</span><span class=nx>props</span><span class=p>.</span><span class=nx>value</span><span class=p>.</span><span class=nx>foo</span> <span class=o>!==</span> <span class=nx>nextProps</span><span class=p>.</span><span class=nx>value</span><span class=p>.</span><span class=nx>foo</span><span class=p>;</span>
<span class=p>}</span>
</code></pre></div><p>In breve, abbiamo finito per effettuare un confronto in profondità per assicurarci di accorgerci correttamente dei cambiamenti. In termini di prestazioni, questo approccio è molto costoso. Non scala in quanto dovremmo scrivere codice diverso per valutare l&#39;uguaglianza in profondità per ciascun modello. Inoltre, potrebbe anche non funzionare per nulla se non gestiamo correttamente i riferimenti agli oggetti. Supponiamo che il componente sia usato da un genitore:</p><div class=highlight><pre><code class=language-javascript data-lang=javascript><span class=nx>React</span><span class=p>.</span><span class=nx>createClass</span><span class=p>({</span>
  <span class=nx>getInitialState</span><span class=o>:</span> <span class=kd>function</span><span class=p>()</span> <span class=p>{</span>
    <span class=k>return</span> <span class=p>{</span> <span class=nx>value</span><span class=o>:</span> <span class=p>{</span> <span class=nx>foo</span><span class=o>:</span> <span class=s1>&#39;bar&#39;</span> <span class=p>}</span> <span class=p>};</span>
  <span class=p>},</span>

  <span class=nx>onClick</span><span class=o>:</span> <span class=kd>function</span><span class=p>()</span> <span class=p>{</span>
    <span class=kd>var</span> <span class=nx>value</span> <span class=o>=</span> <span class=k>this</span><span class=p>.</span><span class=nx>state</span><span class=p>.</span><span class=nx>value</span><span class=p>;</span>
    <span class=nx>value</span><span class=p>.</span><span class=nx>foo</span> <span class=o>+=</span> <span class=s1>&#39;bar&#39;</span><span class=p>;</span> <span class=c1>// ANTI-PATTERN!</span>
    <span class=k>this</span><span class=p>.</span><span class=nx>setState</span><span class=p>({</span> <span class=nx>value</span><span class=o>:</span> <span class=nx>value</span> <span class=p>});</span>
  <span class=p>},</span>

  <span class=nx>render</span><span class=o>:</span> <span class=kd>function</span><span class=p>()</span> <span class=p>{</span>
    <span class=k>return</span> <span class=p>(</span>
      <span class=o>&lt;</span><span class=nx>div</span><span class=o>&gt;</span>
        <span class=o>&lt;</span><span class=nx>InnerComponent</span> <span class=nx>value</span><span class=o>=</span><span class=p>{</span><span class=k>this</span><span class=p>.</span><span class=nx>state</span><span class=p>.</span><span class=nx>value</span><span class=p>}</span> <span class=o>/&gt;</span>
        <span class=o>&lt;</span><span class=nx>a</span> <span class=nx>onClick</span><span class=o>=</span><span class=p>{</span><span class=k>this</span><span class=p>.</span><span class=nx>onClick</span><span class=p>}</span><span class=o>&gt;</span><span class=nx>Click</span> <span class=nx>me</span><span class=o>&lt;</span><span class=err>/a&gt;</span>
      <span class=o>&lt;</span><span class=err>/div&gt;</span>
    <span class=p>);</span>
  <span class=p>}</span>
<span class=p>});</span>
</code></pre></div><p>La prima volta che viene effettuato il rendering del componente interno, la sua proprietà value avrà il valore <code>{ foo: &#39;bar&#39; }</code>. Se l&#39;utente clicca l&#39;ancora, lo stato del componente genitore sarà aggiornato a <code>{ value: { foo: &#39;barbar&#39; } }</code>, scatenando il processo di ri-rendering sul componente interno, il quale riceverà <code>{ foo: &#39;barbar&#39; }</code> come il nuovo valore della proprietà.</p><p>Il problema è che, dal momento che il genitore e il componente interno condividono un riferimento allo stesso oggetto, quando l&#39;oggetto viene modificato nella riga 2 della funzione <code>onClick</code>, la proprietà che il componente interno possedeva cambierà anch&#39;essa. Quindi, quando il processo di ri-rendering inizia, e <code>shouldComponentUpdate</code> viene invocato, <code>this.props.value.foo</code> sarà uguale a <code>nextProps.value.foo</code>, perché infatti, <code>this.props.value</code> si riferisce allo stesso oggetto di <code>nextProps.value</code>.</p><p>Di conseguenza, dal momento che non ci accorgiamo del cambiamento della proprietà e cortocircuitiamo il processo di ri-rendering, la UI non sarà aggiornata da <code>&#39;bar&#39;</code> a <code>&#39;barbar&#39;</code>.</p><h2><a class=anchor name=immutable-js-viene-in-nostro-soccorso></a>Immutable-js viene in nostro soccorso <a href=#immutable-js-viene-in-nostro-soccorso class=hash-link>#</a></h2><p><a href=https://github.com/facebook/immutable-js>Immutable-js</a> è una libreria di collezioni JavaScript scritta da Lee Byron, che Facebook ha recentemente rilasciato come open source. Fornisce collezioni <em>immutabili e persistenti</em> attraverso <em>condivisione strutturale</em>. Vediamo cosa significano queste proprietà:</p><ul><li><em>Immutabile</em>: una volta creata, una collezione non può essere alterata in un momento successivo.</li><li><em>Persistente</em>: nuove collezioni possono essere create da una collezione precedente e una mutazione come un assegnamento. La collezione originale è ancora valida dopo che la nuova collezione è stata creata.</li><li><em>Condivisione Strutturale</em>: nuove collezioni sono create riutilizzando quanto più possibile della stessa struttura della collezione originale, riducendo le operazioni di copia al minimo, per ottenere efficienza spaziale e prestazioni accettabili. Se la nuova collezione è identica all&#39;originale, l&#39;originale è spesso restituita.</li></ul><p>L&#39;immutabilità ci permette di tenere traccia dei cambiamenti in modo economico; un cambiamento risulterà sempre in un nuovo oggetto, quindi dobbiamo soltanto controllare se il riferimento all&#39;oggeto sia cambiato. Ad esempio, in questo codice regolare JavaScript:</p><div class=highlight><pre><code class=language-javascript data-lang=javascript><span class=kd>var</span> <span class=nx>x</span> <span class=o>=</span> <span class=p>{</span> <span class=nx>foo</span><span class=o>:</span> <span class=s2>&quot;bar&quot;</span> <span class=p>};</span>
<span class=kd>var</span> <span class=nx>y</span> <span class=o>=</span> <span class=nx>x</span><span class=p>;</span>
<span class=nx>y</span><span class=p>.</span><span class=nx>foo</span> <span class=o>=</span> <span class=s2>&quot;baz&quot;</span><span class=p>;</span>
<span class=nx>x</span> <span class=o>===</span> <span class=nx>y</span><span class=p>;</span> <span class=c1>// true</span>
</code></pre></div><p>Sebbene <code>y</code> sia stato modificato, dal momento che si tratta di un riferimento allo stesso oggetto di <code>x</code>, questo confronto restituisce <code>true</code>. Tuttavia, questo codice potrebbe essere scritto usando immutable-js come segue:</p><div class=highlight><pre><code class=language-javascript data-lang=javascript><span class=kd>var</span> <span class=nx>SomeRecord</span> <span class=o>=</span> <span class=nx>Immutable</span><span class=p>.</span><span class=nx>Record</span><span class=p>({</span> <span class=nx>foo</span><span class=o>:</span> <span class=kc>null</span> <span class=p>});</span>
<span class=kd>var</span> <span class=nx>x</span> <span class=o>=</span> <span class=k>new</span> <span class=nx>SomeRecord</span><span class=p>({</span> <span class=nx>foo</span><span class=o>:</span> <span class=s1>&#39;bar&#39;</span>  <span class=p>});</span>
<span class=kd>var</span> <span class=nx>y</span> <span class=o>=</span> <span class=nx>x</span><span class=p>.</span><span class=nx>set</span><span class=p>(</span><span class=s1>&#39;foo&#39;</span><span class=p>,</span> <span class=s1>&#39;baz&#39;</span><span class=p>);</span>
<span class=nx>x</span> <span class=o>===</span> <span class=nx>y</span><span class=p>;</span> <span class=c1>// false</span>
</code></pre></div><p>In questo caso, poiché un nuovo riferimento è restituito quando si modifica <code>x</code>, possiamo assumere in tutta sicurezza che <code>x</code> sia cambiato.</p><p>Un&#39;altra maniera possibile di tener traccia dei cambiamenti potrebbe essere il dirty checking, ovvero usare un flag impostato dai metodi setter. Un problema con questo approccio è che ti forza ad usare i setter e scrivere un sacco di codice aggiuntivo, oppure instrumentare in qualche modo le tue classi. In alternativa, puoi effettuare una copia profonda dell&#39;oggetto immediatamente prima della mutazione ed effettuare un confronto in profondità per determinare se vi è stato un cambiamento oppure no. Un problema con questo approccio è che sia deepCopy che deepCompare sono operazioni costose.</p><p>Quindi, le strutture dati Immutable ti forniscono una maniera economica e concisa di osservare i cambiamenti degli oggetti, che è tutto ciò che ci serve per implementare <code>shouldComponentUpdate</code>. Pertanto, se modelliamo gli attributi delle proprietà e dello stato usando le astrazioni fornite da immutable-js saremo in grado di usare <code>PureRenderMixin</code> e ottenere un grande aumento di prestazioni.</p><h2><a class=anchor name=immutable-js-e-flux></a>Immutable-js e Flux <a href=#immutable-js-e-flux class=hash-link>#</a></h2><p>Se stai usando <a href=https://facebook.github.io/flux/ >Flux</a>, dovresti cominciare a scrivere i tuoi store usando immutable-js. Dài un&#39;occhiata alla <a href=https://facebook.github.io/immutable-js/docs/#/ >API completa</a>.</p><p>Vediamo una delle possibili maniere di modellare l&#39;esempio dei thread usando strutture dati Immutable. Anzitutto, dobbiamo definire un <code>Record</code> per ciascuna delle entità che desideriamo modellare. I Record sono semplicemente contenitori immutabili che contengono valori per un insieme specifico di campi:</p><div class=highlight><pre><code class=language-javascript data-lang=javascript><span class=kd>var</span> <span class=nx>User</span> <span class=o>=</span> <span class=nx>Immutable</span><span class=p>.</span><span class=nx>Record</span><span class=p>({</span>
  <span class=nx>id</span><span class=o>:</span> <span class=kc>undefined</span><span class=p>,</span>
  <span class=nx>name</span><span class=o>:</span> <span class=kc>undefined</span><span class=p>,</span>
  <span class=nx>email</span><span class=o>:</span> <span class=kc>undefined</span>
<span class=p>});</span>

<span class=kd>var</span> <span class=nx>Message</span> <span class=o>=</span> <span class=nx>Immutable</span><span class=p>.</span><span class=nx>Record</span><span class=p>({</span>
  <span class=nx>timestamp</span><span class=o>:</span> <span class=k>new</span> <span class=nb>Date</span><span class=p>(),</span>
  <span class=nx>sender</span><span class=o>:</span> <span class=kc>undefined</span><span class=p>,</span>
  <span class=nx>text</span><span class=o>:</span> <span class=s1>&#39;&#39;</span>
<span class=p>});</span>
</code></pre></div><p>La funzione <code>Record</code> riceve un oggetto che definisce i campi che l&#39;oggetto possiede e i loro valori predefiniti.</p><p>Lo <em>store</em> dei messaggi potrebbe tenere traccia degli utenti e dei messaggi usando due liste:</p><div class=highlight><pre><code class=language-javascript data-lang=javascript><span class=k>this</span><span class=p>.</span><span class=nx>users</span> <span class=o>=</span> <span class=nx>Immutable</span><span class=p>.</span><span class=nx>List</span><span class=p>();</span>
<span class=k>this</span><span class=p>.</span><span class=nx>messages</span> <span class=o>=</span> <span class=nx>Immutable</span><span class=p>.</span><span class=nx>List</span><span class=p>();</span>
</code></pre></div><p>Dovrebbe essere abbastanza banale implementare funzioni che gestiscono ciascun tipo di <em>payload</em>. Ad esempio, quando lo store vede un payload che rappresenta un messaggio, possiamo semplicemente creare un nuovo record e metterlo in coda alla lista di messaggi:</p><div class=highlight><pre><code class=language-javascript data-lang=javascript><span class=k>this</span><span class=p>.</span><span class=nx>messages</span> <span class=o>=</span> <span class=k>this</span><span class=p>.</span><span class=nx>messages</span><span class=p>.</span><span class=nx>push</span><span class=p>(</span><span class=k>new</span> <span class=nx>Message</span><span class=p>({</span>
  <span class=nx>timestamp</span><span class=o>:</span> <span class=nx>payload</span><span class=p>.</span><span class=nx>timestamp</span><span class=p>,</span>
  <span class=nx>sender</span><span class=o>:</span> <span class=nx>payload</span><span class=p>.</span><span class=nx>sender</span><span class=p>,</span>
  <span class=nx>text</span><span class=o>:</span> <span class=nx>payload</span><span class=p>.</span><span class=nx>text</span>
<span class=p>});</span>
</code></pre></div><p>Nota che dal momento che le strutture dati sono immutabili, dobbiamo assegnare il valore di ritorno del metodo push a <code>this.messages</code>.</p><p>Dal punto di vista di React, se usiamo strutture dati immutable-js anche per contenere lo stato del componente, possiamo fare il mix di <code>PureRenderMixin</code> in tutti i nostri componenti e cortocircuitare il processo di ri-rendering.</p><div class=docs-prevnext><a href=/fastastic/examples/react/docs/perf-it-IT.html class=docs-prev>&larr; Prev</a></div></div></section><footer class=wrap><div class=left>A Facebook &amp; Instagram collaboration.<br><a href=/fastastic/examples/react/acknowledgements.html>Acknowledgements</a></div><div class=right>&copy; 2013&ndash;2016 Facebook Inc.<br>Documentation licensed under <a href=https://creativecommons.org/licenses/by/4.0/ >CC BY 4.0</a>.</div></footer></div><div id=fb-root></div><script>!function(e,t,n,a,c,o,s){e.GoogleAnalyticsObject=c,e[c]=e[c]||function(){(e[c].q=e[c].q||[]).push(arguments)},e[c].l=1*new Date,o=t.createElement(n),s=t.getElementsByTagName(n)[0],o.async=1,o.src=a,s.parentNode.insertBefore(o,s)}(window,document,"script","//www.google-analytics.com/analytics.js","ga"),ga("create","UA-41298772-1","facebook.github.io"),ga("send","pageview"),!function(e,t,n){var a,c=e.getElementsByTagName(t)[0];e.getElementById(n)||(a=e.createElement(t),a.id=n,a.src="https://platform.twitter.com/widgets.js",c.parentNode.insertBefore(a,c))}(document,"script","twitter-wjs"),function(e,t,n){var a,c=e.getElementsByTagName(t)[0];e.getElementById(n)||(a=e.createElement(t),a.id=n,a.src="//connect.facebook.net/en_US/sdk.js#xfbml=1&version=v2.6&appId=623268441017527",c.parentNode.insertBefore(a,c))}(document,"script","facebook-jssdk"),docsearch({apiKey:"36221914cce388c46d0420343e0bb32e",indexName:"react",inputSelector:"#algolia-doc-search"})</script></body></html>