<!doctype html><html lang=en><head><meta charset=utf-8><title>Modules | Node.js v6.4.0 Documentation</title><link href="https://fonts.googleapis.com/css?family=Lato:400,700,400italic" rel=stylesheet><link href=assets/style.css rel=stylesheet><link href=assets/sh.css rel=stylesheet><link href=https://nodejs.org/api/modules.html rel=canonical></head><body class="alt apidoc" id=api-section-modules><div class=clearfix id=content><div class=interior id=column2><div class=interior id=intro><a href=/ title="Go back to the home page">Node.js</a></div><ul><li><a href=documentation.html class=nav-documentation>About these Docs</a></li><li><a href=synopsis.html class=nav-synopsis>Usage &amp; Example</a></li></ul><div class=line></div><ul><li><a href=assert.html class=nav-assert>Assertion Testing</a></li><li><a href=buffer.html class=nav-buffer>Buffer</a></li><li><a href=addons.html class=nav-addons>C/C++ Addons</a></li><li><a href=child_process.html class=nav-child_process>Child Processes</a></li><li><a href=cluster.html class=nav-cluster>Cluster</a></li><li><a href=cli.html class=nav-cli>Command Line Options</a></li><li><a href=console.html class=nav-console>Console</a></li><li><a href=crypto.html class=nav-crypto>Crypto</a></li><li><a href=debugger.html class=nav-debugger>Debugger</a></li><li><a href=dns.html class=nav-dns>DNS</a></li><li><a href=domain.html class=nav-domain>Domain</a></li><li><a href=errors.html class=nav-errors>Errors</a></li><li><a href=events.html class=nav-events>Events</a></li><li><a href=fs.html class=nav-fs>File System</a></li><li><a href=globals.html class=nav-globals>Globals</a></li><li><a href=http.html class=nav-http>HTTP</a></li><li><a href=https.html class=nav-https>HTTPS</a></li><li><a href=modules.html class="nav-modules active">Modules</a></li><li><a href=net.html class=nav-net>Net</a></li><li><a href=os.html class=nav-os>OS</a></li><li><a href=path.html class=nav-path>Path</a></li><li><a href=process.html class=nav-process>Process</a></li><li><a href=punycode.html class=nav-punycode>Punycode</a></li><li><a href=querystring.html class=nav-querystring>Query Strings</a></li><li><a href=readline.html class=nav-readline>Readline</a></li><li><a href=repl.html class=nav-repl>REPL</a></li><li><a href=stream.html class=nav-stream>Stream</a></li><li><a href=string_decoder.html class=nav-string_decoder>String Decoder</a></li><li><a href=timers.html class=nav-timers>Timers</a></li><li><a href=tls.html class=nav-tls>TLS/SSL</a></li><li><a href=tty.html class=nav-tty>TTY</a></li><li><a href=dgram.html class=nav-dgram>UDP/Datagram</a></li><li><a href=url.html class=nav-url>URL</a></li><li><a href=util.html class=nav-util>Utilities</a></li><li><a href=v8.html class=nav-v8>V8</a></li><li><a href=vm.html class=nav-vm>VM</a></li><li><a href=zlib.html class=nav-zlib>ZLIB</a></li></ul><div class=line></div><ul><li><a href=https://github.com/nodejs/node class=nav-https-github-com-nodejs-node>GitHub Repo &amp; Issue Tracker</a></li><li><a href=http://groups.google.com/group/nodejs class=nav-http-groups-google-com-group-nodejs>Mailing List</a></li></ul></div><div class=interior id=column1 data-id=modules><header><h1>Node.js v6.4.0 Documentation</h1><div id=gtoc><p><a href=index.html name=toc>Index</a> | <a href=all.html>View on single page</a> | <a href=modules.json>View as JSON</a></p></div><hr></header><div id=toc><h2>Table of Contents</h2><ul><li><a href=#modules_modules>Modules</a><ul><li><a href=#modules_accessing_the_main_module>Accessing the main module</a></li><li><a href=#modules_addenda_package_manager_tips>Addenda: Package Manager Tips</a></li><li><a href=#modules_all_together>All Together...</a></li><li><a href=#modules_caching>Caching</a><ul><li><a href=#modules_module_caching_caveats>Module Caching Caveats</a></li></ul></li><li><a href=#modules_core_modules>Core Modules</a></li><li><a href=#modules_cycles>Cycles</a></li><li><a href=#modules_file_modules>File Modules</a></li><li><a href=#modules_folders_as_modules>Folders as Modules</a></li><li><a href=#modules_loading_from_node_modules_folders>Loading from <code>node_modules</code> Folders</a></li><li><a href=#modules_loading_from_the_global_folders>Loading from the global folders</a></li><li><a href=#modules_the_module_wrapper>The module wrapper</a></li><li><a href=#modules_the_module_object>The <code>module</code> Object</a><ul><li><a href=#modules_module_children>module.children</a></li><li><a href=#modules_module_exports>module.exports</a><ul><li><a href=#modules_exports_alias>exports alias</a></li></ul></li><li><a href=#modules_module_filename>module.filename</a></li><li><a href=#modules_module_id>module.id</a></li><li><a href=#modules_module_loaded>module.loaded</a></li><li><a href=#modules_module_parent>module.parent</a></li><li><a href=#modules_module_require_id>module.require(id)</a></li></ul></li></ul></li></ul></div><div id=apicontent><h1>Modules<span><a href=#modules_modules class=mark id=modules_modules>#</a></span></h1><pre class="api_stability api_stability_3">Stability: 3 - Locked</pre><!--name=module--><p>Node.js has a simple module loading system. In Node.js, files and modules are in one-to-one correspondence. As an example, <code>foo.js</code> loads the module <code>circle.js</code> in the same directory.</p><p>The contents of <code>foo.js</code>:</p><pre><code class=lang-js>const circle = require(&#39;./circle.js&#39;);
console.log(`The area of a circle of radius 4 is ${circle.area(4)}`);
</code></pre><p>The contents of <code>circle.js</code>:</p><pre><code class=lang-js>const PI = Math.PI;

exports.area = (r) =&gt; PI * r * r;

exports.circumference = (r) =&gt; 2 * PI * r;
</code></pre><p>The module <code>circle.js</code> has exported the functions <code>area()</code> and <code>circumference()</code>. To add functions and objects to the root of your module, you can add them to the special <code>exports</code> object.</p><p>Variables local to the module will be private, because the module is wrapped in a function by Node.js (see <a href=#modules_the_module_wrapper>module wrapper</a>). In this example, the variable <code>PI</code> is private to <code>circle.js</code>.</p><p>If you want the root of your module&#39;s export to be a function (such as a constructor) or if you want to export a complete object in one assignment instead of building it one property at a time, assign it to <code>module.exports</code> instead of <code>exports</code>.</p><p>Below, <code>bar.js</code> makes use of the <code>square</code> module, which exports a constructor:</p><pre><code class=lang-js>const square = require(&#39;./square.js&#39;);
var mySquare = square(2);
console.log(`The area of my square is ${mySquare.area()}`);
</code></pre><p>The <code>square</code> module is defined in <code>square.js</code>:</p><pre><code class=lang-js>// assigning to exports will not modify module, must use module.exports
module.exports = (width) =&gt; {
  return {
    area: () =&gt; width * width
  };
}
</code></pre><p>The module system is implemented in the <code>require(&quot;module&quot;)</code> module.</p><h2>Accessing the main module<span><a href=#modules_accessing_the_main_module class=mark id=modules_accessing_the_main_module>#</a></span></h2><!-- type=misc --><p>When a file is run directly from Node.js, <code>require.main</code> is set to its <code>module</code>. That means that you can determine whether a file has been run directly by testing</p><pre><code class=lang-js>require.main === module
</code></pre><p>For a file <code>foo.js</code>, this will be <code>true</code> if run via <code>node foo.js</code>, but <code>false</code> if run by <code>require(&#39;./foo&#39;)</code>.</p><p>Because <code>module</code> provides a <code>filename</code> property (normally equivalent to <code>__filename</code>), the entry point of the current application can be obtained by checking <code>require.main.filename</code>.</p><h2>Addenda: Package Manager Tips<span><a href=#modules_addenda_package_manager_tips class=mark id=modules_addenda_package_manager_tips>#</a></span></h2><!-- type=misc --><p>The semantics of Node.js&#39;s <code>require()</code> function were designed to be general enough to support a number of reasonable directory structures. Package manager programs such as <code>dpkg</code>, <code>rpm</code>, and <code>npm</code> will hopefully find it possible to build native packages from Node.js modules without modification.</p><p>Below we give a suggested directory structure that could work:</p><p>Let&#39;s say that we wanted to have the folder at <code>/usr/lib/node/&lt;some-package&gt;/&lt;some-version&gt;</code> hold the contents of a specific version of a package.</p><p>Packages can depend on one another. In order to install package <code>foo</code>, you may have to install a specific version of package <code>bar</code>. The <code>bar</code> package may itself have dependencies, and in some cases, these dependencies may even collide or form cycles.</p><p>Since Node.js looks up the <code>realpath</code> of any modules it loads (that is, resolves symlinks), and then looks for their dependencies in the <code>node_modules</code> folders as described <a href=#modules_loading_from_node_modules_folders>here</a>, this situation is very simple to resolve with the following architecture:</p><ul><li><code>/usr/lib/node/foo/1.2.3/</code> - Contents of the <code>foo</code> package, version 1.2.3.</li><li><code>/usr/lib/node/bar/4.3.2/</code> - Contents of the <code>bar</code> package that <code>foo</code> depends on.</li><li><code>/usr/lib/node/foo/1.2.3/node_modules/bar</code> - Symbolic link to <code>/usr/lib/node/bar/4.3.2/</code>.</li><li><code>/usr/lib/node/bar/4.3.2/node_modules/*</code> - Symbolic links to the packages that <code>bar</code> depends on.</li></ul><p>Thus, even if a cycle is encountered, or if there are dependency conflicts, every module will be able to get a version of its dependency that it can use.</p><p>When the code in the <code>foo</code> package does <code>require(&#39;bar&#39;)</code>, it will get the version that is symlinked into <code>/usr/lib/node/foo/1.2.3/node_modules/bar</code>. Then, when the code in the <code>bar</code> package calls <code>require(&#39;quux&#39;)</code>, it&#39;ll get the version that is symlinked into <code>/usr/lib/node/bar/4.3.2/node_modules/quux</code>.</p><p>Furthermore, to make the module lookup process even more optimal, rather than putting packages directly in <code>/usr/lib/node</code>, we could put them in <code>/usr/lib/node_modules/&lt;name&gt;/&lt;version&gt;</code>. Then Node.js will not bother looking for missing dependencies in <code>/usr/node_modules</code> or <code>/node_modules</code>.</p><p>In order to make modules available to the Node.js REPL, it might be useful to also add the <code>/usr/lib/node_modules</code> folder to the <code>$NODE_PATH</code> environment variable. Since the module lookups using <code>node_modules</code> folders are all relative, and based on the real path of the files making the calls to <code>require()</code>, the packages themselves can be anywhere.</p><h2>All Together...<span><a href=#modules_all_together class=mark id=modules_all_together>#</a></span></h2><!-- type=misc --><p>To get the exact filename that will be loaded when <code>require()</code> is called, use the <code>require.resolve()</code> function.</p><p>Putting together all of the above, here is the high-level algorithm in pseudocode of what require.resolve does:</p><pre><code class=lang-txt>require(X) from module at path Y
1. If X is a core module,
   a. return the core module
   b. STOP
2. If X begins with &#39;./&#39; or &#39;/&#39; or &#39;../&#39;
   a. LOAD_AS_FILE(Y + X)
   b. LOAD_AS_DIRECTORY(Y + X)
3. LOAD_NODE_MODULES(X, dirname(Y))
4. THROW &quot;not found&quot;

LOAD_AS_FILE(X)
1. If X is a file, load X as JavaScript text.  STOP
2. If X.js is a file, load X.js as JavaScript text.  STOP
3. If X.json is a file, parse X.json to a JavaScript Object.  STOP
4. If X.node is a file, load X.node as binary addon.  STOP

LOAD_AS_DIRECTORY(X)
1. If X/package.json is a file,
   a. Parse X/package.json, and look for &quot;main&quot; field.
   b. let M = X + (json main field)
   c. LOAD_AS_FILE(M)
2. If X/index.js is a file, load X/index.js as JavaScript text.  STOP
3. If X/index.json is a file, parse X/index.json to a JavaScript object. STOP
4. If X/index.node is a file, load X/index.node as binary addon.  STOP

LOAD_NODE_MODULES(X, START)
1. let DIRS=NODE_MODULES_PATHS(START)
2. for each DIR in DIRS:
   a. LOAD_AS_FILE(DIR/X)
   b. LOAD_AS_DIRECTORY(DIR/X)

NODE_MODULES_PATHS(START)
1. let PARTS = path split(START)
2. let I = count of PARTS - 1
3. let DIRS = []
4. while I &gt;= 0,
   a. if PARTS[I] = &quot;node_modules&quot; CONTINUE
   c. DIR = path join(PARTS[0 .. I] + &quot;node_modules&quot;)
   b. DIRS = DIRS + DIR
   c. let I = I - 1
5. return DIRS
</code></pre><h2>Caching<span><a href=#modules_caching class=mark id=modules_caching>#</a></span></h2><!--type=misc--><p>Modules are cached after the first time they are loaded. This means (among other things) that every call to <code>require(&#39;foo&#39;)</code> will get exactly the same object returned, if it would resolve to the same file.</p><p>Multiple calls to <code>require(&#39;foo&#39;)</code> may not cause the module code to be executed multiple times. This is an important feature. With it, &quot;partially done&quot; objects can be returned, thus allowing transitive dependencies to be loaded even when they would cause cycles.</p><p>If you want to have a module execute code multiple times, then export a function, and call that function.</p><h3>Module Caching Caveats<span><a href=#modules_module_caching_caveats class=mark id=modules_module_caching_caveats>#</a></span></h3><!--type=misc--><p>Modules are cached based on their resolved filename. Since modules may resolve to a different filename based on the location of the calling module (loading from <code>node_modules</code> folders), it is not a <em>guarantee</em> that <code>require(&#39;foo&#39;)</code> will always return the exact same object, if it would resolve to different files.</p><p>Additionally, on case-insensitive file systems or operating systems, different resolved filenames can point to the same file, but the cache will still treat them as different modules and will reload the file multiple times. For example, <code>require(&#39;./foo&#39;)</code> and <code>require(&#39;./FOO&#39;)</code> return two different objects, irrespective of whether or not <code>./foo</code> and <code>./FOO</code> are the same file.</p><h2>Core Modules<span><a href=#modules_core_modules class=mark id=modules_core_modules>#</a></span></h2><!--type=misc--><p>Node.js has several modules compiled into the binary. These modules are described in greater detail elsewhere in this documentation.</p><p>The core modules are defined within Node.js&#39;s source and are located in the <code>lib/</code> folder.</p><p>Core modules are always preferentially loaded if their identifier is passed to <code>require()</code>. For instance, <code>require(&#39;http&#39;)</code> will always return the built in HTTP module, even if there is a file by that name.</p><h2>Cycles<span><a href=#modules_cycles class=mark id=modules_cycles>#</a></span></h2><!--type=misc--><p>When there are circular <code>require()</code> calls, a module might not have finished executing when it is returned.</p><p>Consider this situation:</p><p><code>a.js</code>:</p><pre><code class=lang-js>console.log(&#39;a starting&#39;);
exports.done = false;
const b = require(&#39;./b.js&#39;);
console.log(&#39;in a, b.done = %j&#39;, b.done);
exports.done = true;
console.log(&#39;a done&#39;);
</code></pre><p><code>b.js</code>:</p><pre><code class=lang-js>console.log(&#39;b starting&#39;);
exports.done = false;
const a = require(&#39;./a.js&#39;);
console.log(&#39;in b, a.done = %j&#39;, a.done);
exports.done = true;
console.log(&#39;b done&#39;);
</code></pre><p><code>main.js</code>:</p><pre><code class=lang-js>console.log(&#39;main starting&#39;);
const a = require(&#39;./a.js&#39;);
const b = require(&#39;./b.js&#39;);
console.log(&#39;in main, a.done=%j, b.done=%j&#39;, a.done, b.done);
</code></pre><p>When <code>main.js</code> loads <code>a.js</code>, then <code>a.js</code> in turn loads <code>b.js</code>. At that point, <code>b.js</code> tries to load <code>a.js</code>. In order to prevent an infinite loop, an <strong>unfinished copy</strong> of the <code>a.js</code> exports object is returned to the <code>b.js</code> module. <code>b.js</code> then finishes loading, and its <code>exports</code> object is provided to the <code>a.js</code> module.</p><p>By the time <code>main.js</code> has loaded both modules, they&#39;re both finished. The output of this program would thus be:</p><pre><code class=lang-txt>$ node main.js
main starting
a starting
b starting
in b, a.done = false
b done
in a, b.done = true
a done
in main, a.done=true, b.done=true
</code></pre><p>If you have cyclic module dependencies in your program, make sure to plan accordingly.</p><h2>File Modules<span><a href=#modules_file_modules class=mark id=modules_file_modules>#</a></span></h2><!--type=misc--><p>If the exact filename is not found, then Node.js will attempt to load the required filename with the added extensions: <code>.js</code>, <code>.json</code>, and finally <code>.node</code>.</p><p><code>.js</code> files are interpreted as JavaScript text files, and <code>.json</code> files are parsed as JSON text files. <code>.node</code> files are interpreted as compiled addon modules loaded with <code>dlopen</code>.</p><p>A required module prefixed with <code>&#39;/&#39;</code> is an absolute path to the file. For example, <code>require(&#39;/home/marco/foo.js&#39;)</code> will load the file at <code>/home/marco/foo.js</code>.</p><p>A required module prefixed with <code>&#39;./&#39;</code> is relative to the file calling <code>require()</code>. That is, <code>circle.js</code> must be in the same directory as <code>foo.js</code> for <code>require(&#39;./circle&#39;)</code> to find it.</p><p>Without a leading &#39;/&#39;, &#39;./&#39;, or &#39;../&#39; to indicate a file, the module must either be a core module or is loaded from a <code>node_modules</code> folder.</p><p>If the given path does not exist, <code>require()</code> will throw an <a href=errors.html#errors_class_error><code>Error</code></a> with its <code>code</code> property set to <code>&#39;MODULE_NOT_FOUND&#39;</code>.</p><h2>Folders as Modules<span><a href=#modules_folders_as_modules class=mark id=modules_folders_as_modules>#</a></span></h2><!--type=misc--><p>It is convenient to organize programs and libraries into self-contained directories, and then provide a single entry point to that library. There are three ways in which a folder may be passed to <code>require()</code> as an argument.</p><p>The first is to create a <code>package.json</code> file in the root of the folder, which specifies a <code>main</code> module. An example package.json file might look like this:</p><pre><code class=lang-json>{ &quot;name&quot; : &quot;some-library&quot;,
  &quot;main&quot; : &quot;./lib/some-library.js&quot; }
</code></pre><p>If this was in a folder at <code>./some-library</code>, then <code>require(&#39;./some-library&#39;)</code> would attempt to load <code>./some-library/lib/some-library.js</code>.</p><p>This is the extent of Node.js&#39;s awareness of package.json files.</p><p>Note: If the file specified by the <code>&quot;main&quot;</code> entry of <code>package.json</code> is missing and can not be resolved, Node.js will report the entire module as missing with the default error:</p><pre><code class=lang-txt>Error: Cannot find module &#39;some-library&#39;
</code></pre><p>If there is no package.json file present in the directory, then Node.js will attempt to load an <code>index.js</code> or <code>index.node</code> file out of that directory. For example, if there was no package.json file in the above example, then <code>require(&#39;./some-library&#39;)</code> would attempt to load:</p><ul><li><code>./some-library/index.js</code></li><li><code>./some-library/index.node</code></li></ul><h2>Loading from <code>node_modules</code> Folders<span><a href=#modules_loading_from_node_modules_folders class=mark id=modules_loading_from_node_modules_folders>#</a></span></h2><!--type=misc--><p>If the module identifier passed to <code>require()</code> is not a native module, and does not begin with <code>&#39;/&#39;</code>, <code>&#39;../&#39;</code>, or <code>&#39;./&#39;</code>, then Node.js starts at the parent directory of the current module, and adds <code>/node_modules</code>, and attempts to load the module from that location. Node will not append <code>node_modules</code> to a path already ending in <code>node_modules</code>.</p><p>If it is not found there, then it moves to the parent directory, and so on, until the root of the file system is reached.</p><p>For example, if the file at <code>&#39;/home/ry/projects/foo.js&#39;</code> called <code>require(&#39;bar.js&#39;)</code>, then Node.js would look in the following locations, in this order:</p><ul><li><code>/home/ry/projects/node_modules/bar.js</code></li><li><code>/home/ry/node_modules/bar.js</code></li><li><code>/home/node_modules/bar.js</code></li><li><code>/node_modules/bar.js</code></li></ul><p>This allows programs to localize their dependencies, so that they do not clash.</p><p>You can require specific files or sub modules distributed with a module by including a path suffix after the module name. For instance <code>require(&#39;example-module/path/to/file&#39;)</code> would resolve <code>path/to/file</code> relative to where <code>example-module</code> is located. The suffixed path follows the same module resolution semantics.</p><h2>Loading from the global folders<span><a href=#modules_loading_from_the_global_folders class=mark id=modules_loading_from_the_global_folders>#</a></span></h2><!-- type=misc --><p>If the <code>NODE_PATH</code> environment variable is set to a colon-delimited list of absolute paths, then Node.js will search those paths for modules if they are not found elsewhere. (Note: On Windows, <code>NODE_PATH</code> is delimited by semicolons instead of colons.)</p><p><code>NODE_PATH</code> was originally created to support loading modules from varying paths before the current <a href=#modules_all_together>module resolution</a> algorithm was frozen.</p><p><code>NODE_PATH</code> is still supported, but is less necessary now that the Node.js ecosystem has settled on a convention for locating dependent modules. Sometimes deployments that rely on <code>NODE_PATH</code> show surprising behavior when people are unaware that <code>NODE_PATH</code> must be set. Sometimes a module&#39;s dependencies change, causing a different version (or even a different module) to be loaded as the <code>NODE_PATH</code> is searched.</p><p>Additionally, Node.js will search in the following locations:</p><ul><li>1: <code>$HOME/.node_modules</code></li><li>2: <code>$HOME/.node_libraries</code></li><li>3: <code>$PREFIX/lib/node</code></li></ul><p>Where <code>$HOME</code> is the user&#39;s home directory, and <code>$PREFIX</code> is Node.js&#39;s configured <code>node_prefix</code>.</p><p>These are mostly for historic reasons. <strong>You are highly encouraged to place your dependencies locally in <code>node_modules</code> folders.</strong> They will be loaded faster, and more reliably.</p><h2>The module wrapper<span><a href=#modules_the_module_wrapper class=mark id=modules_the_module_wrapper>#</a></span></h2><!-- type=misc --><p>Before a module&#39;s code is executed, Node.js will wrap it with a function wrapper that looks like the following:</p><pre><code class=lang-js>(function (exports, require, module, __filename, __dirname) {
// Your module code actually lives in here
});
</code></pre><p>By doing this, Node.js achieves a few things:</p><ul><li>It keeps top-level variables (defined with <code>var</code>, <code>const</code> or <code>let</code>) scoped to the module rather than the global object.</li><li>It helps to provide some global-looking variables that are actually specific to the module, such as:<ul><li>The <code>module</code> and <code>exports</code> objects that the implementor can use to export values from the module.</li><li>The convenience variables <code>__filename</code> and <code>__dirname</code>, containing the module&#39;s absolute filename and directory path.</li></ul></li></ul><h2>The <code>module</code> Object<span><a href=#modules_the_module_object class=mark id=modules_the_module_object>#</a></span></h2><!-- type=var --><!-- name=module --><ul><li><a href=https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object class=type>&lt;Object&gt;</a></li></ul><p>In each module, the <code>module</code> free variable is a reference to the object representing the current module. For convenience, <code>module.exports</code> is also accessible via the <code>exports</code> module-global. <code>module</code> isn&#39;t actually a global but rather local to each module.</p><h3>module.children<span><a href=#modules_module_children class=mark id=modules_module_children>#</a></span></h3><div class=signature><ul><li><a href=https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array class=type>&lt;Array&gt;</a></li></ul></div><p>The module objects required by this one.</p><h3>module.exports<span><a href=#modules_module_exports class=mark id=modules_module_exports>#</a></span></h3><div class=signature><ul><li><a href=https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object class=type>&lt;Object&gt;</a></li></ul></div><p>The <code>module.exports</code> object is created by the Module system. Sometimes this is not acceptable; many want their module to be an instance of some class. To do this, assign the desired export object to <code>module.exports</code>. Note that assigning the desired object to <code>exports</code> will simply rebind the local <code>exports</code> variable, which is probably not what you want to do.</p><p>For example suppose we were making a module called <code>a.js</code></p><pre><code class=lang-js>const EventEmitter = require(&#39;events&#39;);

module.exports = new EventEmitter();

// Do some work, and after some time emit
// the &#39;ready&#39; event from the module itself.
setTimeout(() =&gt; {
  module.exports.emit(&#39;ready&#39;);
}, 1000);
</code></pre><p>Then in another file we could do</p><pre><code class=lang-js>const a = require(&#39;./a&#39;);
a.on(&#39;ready&#39;, () =&gt; {
  console.log(&#39;module a is ready&#39;);
});
</code></pre><p>Note that assignment to <code>module.exports</code> must be done immediately. It cannot be done in any callbacks. This does not work:</p><p>x.js:</p><pre><code class=lang-js>setTimeout(() =&gt; {
  module.exports = { a: &#39;hello&#39; };
}, 0);
</code></pre><p>y.js:</p><pre><code class=lang-js>const x = require(&#39;./x&#39;);
console.log(x.a);
</code></pre><h4>exports alias<span><a href=#modules_exports_alias class=mark id=modules_exports_alias>#</a></span></h4><p>The <code>exports</code> variable that is available within a module starts as a reference to <code>module.exports</code>. As with any variable, if you assign a new value to it, it is no longer bound to the previous value.</p><p>To illustrate the behavior, imagine this hypothetical implementation of <code>require()</code>:</p><pre><code class=lang-js>function require(...) {
  // ...
  ((module, exports) =&gt; {
    // Your module code here
    exports = some_func;        // re-assigns exports, exports is no longer
                                // a shortcut, and nothing is exported.
    module.exports = some_func; // makes your module export 0
  })(module, module.exports);
  return module;
}
</code></pre><p>As a guideline, if the relationship between <code>exports</code> and <code>module.exports</code> seems like magic to you, ignore <code>exports</code> and only use <code>module.exports</code>.</p><h3>module.filename<span><a href=#modules_module_filename class=mark id=modules_module_filename>#</a></span></h3><div class=signature><ul><li><a href=https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type class=type>&lt;String&gt;</a></li></ul></div><p>The fully resolved filename to the module.</p><h3>module.id<span><a href=#modules_module_id class=mark id=modules_module_id>#</a></span></h3><div class=signature><ul><li><a href=https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type class=type>&lt;String&gt;</a></li></ul></div><p>The identifier for the module. Typically this is the fully resolved filename.</p><h3>module.loaded<span><a href=#modules_module_loaded class=mark id=modules_module_loaded>#</a></span></h3><div class=signature><ul><li><a href=https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Boolean_type class=type>&lt;Boolean&gt;</a></li></ul></div><p>Whether or not the module is done loading, or is in the process of loading.</p><h3>module.parent<span><a href=#modules_module_parent class=mark id=modules_module_parent>#</a></span></h3><div class=signature><ul><li><a href=https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object class=type>&lt;Object&gt;</a> Module object</li></ul></div><p>The module that first required this one.</p><h3>module.require(id)<span><a href=#modules_module_require_id class=mark id=modules_module_require_id>#</a></span></h3><div class=signature><ul><li><code>id</code> <a href=https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type class=type>&lt;String&gt;</a></li><li>Return: <a href=https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object class=type>&lt;Object&gt;</a> <code>module.exports</code> from the resolved module</li></ul></div><p>The <code>module.require</code> method provides a way to load a module as if <code>require()</code> was called from the original module.</p><p>Note that in order to do this, you must get a reference to the <code>module</code> object. Since <code>require()</code> returns the <code>module.exports</code>, and the <code>module</code> is typically <em>only</em> available within a specific module&#39;s code, it must be explicitly exported in order to be used.</p></div></div></div><script src=assets/sh_main.js></script><script src=assets/sh_javascript.min.js></script><script>highlight(void 0,void 0,"pre")</script></body></html>